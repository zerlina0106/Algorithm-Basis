### 枚举
##### 基于已有知识进行答案猜测的一种问题求解策略  

    例子：求小于N的最大素数  
        没有公式直接判断  
        依次判断N-1 N-2是否为素数--》判断N-K是否为素数：N-K不能被任何一个大于1，小于N-K的素数整除  
        将判断N-K是否为素数转化为求小于N-K的全部素数  
       解决办法：  
        2是素数，记为PRIM0...寻找到比PRIMK大的最小素数PRIMK+1，如果PRIMK+1>N,那么PRIMK就是我们要找到素数，否则继续寻找  
##### 思想：猜测  
       从可能的集合中一一列举各元素  
##### 枚举算法  
        对问题可能解集合中的每一项  
        根据问题给定的检验条件判定哪些是成立的  
        使条件成立的即是问题的解  
        
        过程：
         判断猜测的答案是否正确  （2是小于N的最大素数吗）
         进行新的猜测：  
                1. 猜测的结果必须是之前没有猜测过的状态（每次猜测的素数一定比之前找到的大）  
                2. 猜测的过程中要及早的排除错误的答案（除了2之外，只有奇数才能是素数）
                
##### 枚举中三个关键问题  
        1. 给出解空间，建立简洁的数学模型  
            可能的情况是什么
            模型中变量数尽可能少，它们之间相互独立
            （求小于N的最大素数条件应为n不能被[2,n)中任意一个素数整除，而不是n不能被[2,n)中任意一个整数整除）
        2. 减少搜索的空间
            利用已有的知识缩小模型中各变量的取值范围，避免不必要的计算
            减少代码中循环体执行次数（除2之外只有奇数才可能是素数{2,2*i+1|1<=i,2*i+1<n}）
        3. 合适的搜索顺序
            搜索空间的遍历顺序要与模型中条件表达式一致，保证过程中下一个猜测值的有效性和准确性
            {2,2*i+1|1<=i,2*i+1<n}按照由小到大顺序
            
##### 百钱百鸡问题
    求解方法：
        先构造可能的解空间 S={(X,Y,Z)|0<=X,Y,Z<=100}
        然后验证条件X+Y+Z=100, 5X+3Y+Z/3=100
        复杂度 O(100^2) 
 -------
#### 熄灯问题

##### 问题描述
    有一个5*6的按钮矩阵，每隔位置有一盏对应的灯  
    当按下一个按钮后，该按钮周围（上下左右）都会改变，当前按钮的灯也会改变
    矩阵边角的按钮改变3盏灯状态，边缘按钮改变4盏，其他位置按钮改变五盏灯
    一盏灯周围多个按钮被按下，一个操作会抵消另一次操作的结果
    对矩阵中每盏灯设置一个初始状态，如何操作使得全部的灯被熄灭
    
    输入：
        第一行是一个正整数N，要解决的case数
        每个案例五行组成，每一行6个数字
        数字空格隔开 0、1
        0 灯初始熄灭 1 灯初始点亮
    输出：
        每个案例首先输出一行
            输出字符串"PUZZLE #m"其中m是该案例的序号
        按照该案例的输入格式输出五行
        1表示需要把对应按钮按下 0表示不需要按对应按钮 每个数字空格隔开
        
    解题分析：
        第二次按下同一个按钮时，会抵消第一次按下时所产生的结果
        ->每个按钮最多只需要按下一次
        各个按钮被按下的顺序对最终的结果没有影响
        对于第一行中每盏点亮的灯，按下第二行对应的按钮，就可以熄灭第一行的全部灯
        如此重复会导致1 2 3 4行的灯
        （1）枚举所有可能的按钮状态，计算最后灯的情况
             每一个按钮有两种状态1/0 一共5*6，那么状态数2^30会超时
             --------
         基本思路：如果存在某个局部，一旦这个局部的状态被确定，那么剩余的其他部分的状态被确定，
         那么剩余其他部分的状态只能是确定的一种，或者不多的n种，那么只要枚举这个局部的状态即可
         
         第一行就是局部：
            第一行的各个开关状态确定的情况下，第一行这些开关作用过后，将导致第一行某些灯是亮的，某些灯是灭的
            如果要熄灭第一行某个亮着灯（位于i列），那么唯一解决办法就是按下第二行i列的开关
            （因为第一行开关用过了，第三行及以后开关不会影响第一行）
            为了第i行的灯全部熄灭，第i+1行的合理开关状态就是唯一的了
            那么第一行状态定下来，剩余行的情况就是确定的了，那么只需要推算出最后一行的开关状态，看看是否可以在所有开关
            起完作用之后，最后一行能否使最后一行的灯都熄灭，如果是，那么A就是一个解的状态，如果不是，第一行换一个状态试试
            那么只用枚举第一行的状态，状态数2^6=64
         更少的状态数->按列枚举
         
         具体实现：
            puzzle[5][6]表示灯初始状态
            press[5][6]表示计算的结果，是否按下
            a. 六重循环
            for(int a0=0; a0<2; a0++)...每个开关一个循环
            b. 将按钮矩阵第一行看作一个二进制数，通过++操作来累加，获得每一个枚举的64个状态
            c. 原本是5*6的矩阵，可以用6*8的数组来表示按钮矩阵
                简化计算数组下一行的值得计算公式，就不用分边上 角上，都变成了中间不特殊的位置
                多出来的方便计算的行列值都置零
               给定press的第一行的取值，那么其他行
               press[r+1][c] = (puzzle[r][c]+press[r][c-1]+press[r][c]+press[r][c+1]+press[r-1][c])%2
               (r+1,c)位置按或者不按，通过前一行对应位置的初始状态以及自己周围所有按钮的按的情况加起来，如果是0，那么就说明这里不需要
               按，如果是1，那么久需要熄灭这盏灯
               
               
```
  #include<stdio.h>
  int puzzle[6][8], press[6][8];
  bool guess(){
   int c,r;
   for(r=1; r<5; r++) //根据给定的puzzle press第一行计算press其他行的值
       for(c=1; c<7; c++)
           press[r+1][c] = (puzzle[r][c]+press[r][c]+press[r-1][c]+press[r][c-1]+press[r][c+1])%2;
   for(c=1; c<7; c++)//推出press，看看第五行的每一列，判断第五行中每一个值周围的操作之后是否与之前的值一致，
                       如果那些操作后导致的灯状态与灯原本状态一致，灯会被熄灭，那么返回TRUE，不等，那么第一行的状态不对
       if((press[5][c-1]+press[5][c]+press[5][c+1]+press[4][c])%2 != puzzle[5][c])
           return false;
   return true;
  }

  void enumerate(){ //枚举第一行元素状态
   int c;
   bool success;
   for(c=1; c<7; c++)
       press[1][c] = 0; //第一行初始状态都是0
   while(guess()==false){ //如果guess的是错的，那么就要重新换第一行的值
       press[1][1]++; //1 0 0 0 0 0 
       c = 1;
       while(press[1][c] > 1){ //用于累加进位，如果加完之后大于1了，就要此位为0 下一位1 
           press[1][c] = 0;
           c++;
           press[1][c]++;
       }
   }
   return;
  }
  
  int main(){
    int cases,i,r,c;
    scanf("%d",&cases);
    for(r=0;r<6;r++)//周围一圈0 padding
        press[r][0] = press[r][7] = 0;
    for(c=1;r<7;r++)
        press[0][c] = 0;
    for(i=0; i<cases; i++){
        for(r=1; r<6;r++)
            for(c=1;c<7;c++)
                scanf("%d",&puzzle[r][c]);//给实际5*6的数组赋值
    }
    enumerate();
    printf("PUZZLE #%d\n",i+1);
    for(r=1;r<6;r++){
        for(c=1;c<7;c++)
            printf("%d ",press[r][c]);
        printf("\n");
    }
    return 0;
  }
  
```

    总结
    1. 枚举过程 enumerate()
        press[1][]中每个元素代表一个二进制数0/1
    

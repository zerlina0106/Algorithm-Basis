#### 熄灯问题

##### 问题描述
    有一个5*6的按钮矩阵，每隔位置有一盏对应的灯  
    当按下一个按钮后，该按钮周围（上下左右）都会改变，当前按钮的灯也会改变
    矩阵边角的按钮改变3盏灯状态，边缘按钮改变4盏，其他位置按钮改变五盏灯
    一盏灯周围多个按钮被按下，一个操作会抵消另一次操作的结果
    对矩阵中每盏灯设置一个初始状态，如何操作使得全部的灯被熄灭
    
    输入：
        第一行是一个正整数N，要解决的case数
        每个案例五行组成，每一行6个数字
        数字空格隔开 0、1
        0 灯初始熄灭 1 灯初始点亮
    输出：
        每个案例首先输出一行
            输出字符串"PUZZLE #m"其中m是该案例的序号
        按照该案例的输入格式输出五行
        1表示需要把对应按钮按下 0表示不需要按对应按钮 每个数字空格隔开
        
    解题分析：
        第二次按下同一个按钮时，会抵消第一次按下时所产生的结果
        ->每个按钮最多只需要按下一次
        各个按钮被按下的顺序对最终的结果没有影响
        对于第一行中每盏点亮的灯，按下第二行对应的按钮，就可以熄灭第一行的全部灯
        如此重复会导致1 2 3 4行的灯
        （1）枚举所有可能的按钮状态，计算最后灯的情况
             每一个按钮有两种状态1/0 一共5*6，那么状态数2^30会超时
             --------
         基本思路：如果存在某个局部，一旦这个局部的状态被确定，那么剩余的其他部分的状态被确定，
         那么剩余其他部分的状态只能是确定的一种，或者不多的n种，那么只要枚举这个局部的状态即可
         
         第一行就是局部：
            第一行的各个开关状态确定的情况下，第一行这些开关作用过后，将导致第一行某些灯是亮的，某些灯是灭的
            如果要熄灭第一行某个亮着灯（位于i列），那么唯一解决办法就是按下第二行i列的开关
            （因为第一行开关用过了，第三行及以后开关不会影响第一行）
            为了第i行的灯全部熄灭，第i+1行的合理开关状态就是唯一的了
            那么第一行状态定下来，剩余行的情况就是确定的了，那么只需要推算出最后一行的开关状态，看看是否可以在所有开关
            起完作用之后，最后一行能否使最后一行的灯都熄灭，如果是，那么A就是一个解的状态，如果不是，第一行换一个状态试试
            那么只用枚举第一行的状态，状态数2^6=64
         更少的状态数->按列枚举
         
         具体实现：
            puzzle[5][6]表示灯初始状态
            press[5][6]表示计算的结果，是否按下
            a. 六重循环
            for(int a0=0; a0<2; a0++)...每个开关一个循环
            b. 将按钮矩阵第一行看作一个二进制数，通过++操作来累加，获得每一个枚举的64个状态
            c. 原本是5*6的矩阵，可以用6*8的数组来表示按钮矩阵
                简化计算数组下一行的值得计算公式，就不用分边上 角上，都变成了中间不特殊的位置
                多出来的方便计算的行列值都置零
               给定press的第一行的取值，那么其他行
               press[r+1][c] = (puzzle[r][c]+press[r][c-1]+press[r][c]+press[r][c+1]+press[r-1][c])%2
               (r+1,c)位置按或者不按，通过前一行对应位置的初始状态以及自己周围所有按钮的按的情况加起来，如果是0，那么就说明这里不需要
               按，如果是1，那么久需要熄灭这盏灯
               
               
```
  #include<stdio.h>
  int puzzle[6][8], press[6][8];
  bool guess(){
   int c,r;
   for(r=1; r<5; r++) //根据给定的puzzle press第一行计算press其他行的值
       for(c=1; c<7; c++)
           press[r+1][c] = (puzzle[r][c]+press[r][c]+press[r-1][c]+press[r][c-1]+press[r][c+1])%2;
   for(c=1; c<7; c++)//推出press，看看第五行的每一列，判断第五行中每一个值周围的操作之后是否与之前的值一致，
                       如果那些操作后导致的灯状态与灯原本状态一致，灯会被熄灭，那么返回TRUE，不等，那么第一行的状态不对
       if((press[5][c-1]+press[5][c]+press[5][c+1]+press[4][c])%2 != puzzle[5][c])
           return false;
   return true;
  }

  void enumerate(){ //枚举第一行元素状态
   int c;
   bool success;
   for(c=1; c<7; c++)
       press[1][c] = 0; //第一行初始状态都是0
   while(guess()==false){ //如果guess的是错的，那么就要重新换第一行的值
       press[1][1]++; //1 0 0 0 0 0 
       c = 1;
       while(press[1][c] > 1){ //用于累加进位，如果加完之后大于1了，就要此位为0 下一位1 
           press[1][c] = 0;
           c++;
           press[1][c]++;
       }
   }
   return;
  }
  
  int main(){
    int cases,i,r,c;
    scanf("%d",&cases);
    for(r=0;r<6;r++)//周围一圈0 padding
        press[r][0] = press[r][7] = 0;
    for(c=1;r<7;r++)
        press[0][c] = 0;
    for(i=0; i<cases; i++){
        for(r=1; r<6;r++)
            for(c=1;c<7;c++)
                scanf("%d",&puzzle[r][c]);//给实际5*6的数组赋值
    }
    enumerate();
    printf("PUZZLE #%d\n",i+1);
    for(r=1;r<6;r++){
        for(c=1;c<7;c++)
            printf("%d ",press[r][c]);
        printf("\n");
    }
    return 0;
  }
  
```

    总结
    1. 枚举过程 enumerate()
        press[1][]中每个元素代表一个二进制数0/1
        通过模拟二进制加法的方式实现枚举，自己进位分析
    2. 推测验证过程 guess()
        用6*8按钮矩阵来简化下一行按钮值的计算公式
        根据press[1][]和puzzle数组
        用公式计算使得1-4行所有灯都熄灭的press其他行的值
        再判断所计算的press数组是否熄灭矩阵第5行的所有灯
    
